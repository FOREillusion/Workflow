[andyguo.blog.csdn.net](https://andyguo.blog.csdn.net/article/details/104351765)

# 计算机组成原理-宝典_明确目标，勿欺骗自己，小白冲冲冲-CSDN博客

106-133 分钟

---

_**时间单位：s   ms   μs   ns  依次相差1000倍**_  
_**65536=2^16**_

**目录**

---

## **1.移码和补码的关系**

同一数值的移码与补码符号位相反,其它各位相同；故0的移码和补码表示形式唯一。

![](https://img-blog.csdnimg.cn/20200921162154498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

## **2.地址映射** 

**在虚拟存储器中，当程序正在执行时，由____完成地址映射。**  
A．程序员  B．编译器  C．装入程序  D．操作系统          答案：D  
程序在系统中运行，须经过以下步骤。

1.  编译，由编译程序对用户源程序进行编译，形成若干个目标模块
2.  链接，由链接程序将编译后形成的一组目标模块以及他们所需要的库函数链接在一起，形成一个完整的装入模块；
3.  装入（虚拟地址-->物理地址），由装入程序（Loader)将装入模块装入内存。因此在实际运行时，已经编译且装入过了，地址映射交由操作系统来完成，对程序员透明

形成逻辑地址——【链接阶段】；完成虚实地址转换——【装载阶段】。  
**链接举例**：如C语言编译出main.c file1.c file1.h等，在链接前一步生成了file1.o等目标模块（都是逻辑地址从0开始的东东），把这三个目标模块和libc和库文件【**链接**】成一个可执行文件（形成整个程序的**逻辑地址**）。

![](https://img-blog.csdnimg.cn/20200815153553172.png)

【翻译程序】实现 ：高级语言程序--->机器语言程序（目标代码）  
——分为【编译】（一次全部翻译成目标程序）和【解释】（翻译一句执行一句，不会生成目标程序）。  
【注意】汇编程序属于【解释】方式——将汇编语言源程序翻译为机器语言程序（目标代码）。

## **3.总线tips**

**挂接在总线上的多个部件 只能分时向总线发送数据，但可同时从总线接收数据。**

（正确）单总线结构中，可以不用I/O指令——CPU、主存和I/O设备（通过I/O接口）都挂在一组总线上，若设备和主存统一编址，则可方便地使用访存指令访问I/O设备。  
（错误）异步总线中，传送操作由设备控制器控制。——异步通信的总线，没有公共时钟，依靠的是传送双方相互制约的握手信号来实现定时控制。

**计算：**总线的宽度是数据总线的位数，与地址总线/控制总线位数无关。  
总线数据传输率=总线工作频率 × （总线宽度/8）  
——总线宽度（位宽）：总线能同时传输的数据位数=数据总线的根数，如32根称为32位总线。  
【**总线集中仲裁**】的三种方式：

![](https://img-blog.csdnimg.cn/20201102135601967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)  
计数器定时查询的栗子：8个I/O设备，需3根设备地址线对应。若每次计数器从0开始计，则设备小的优先级**max**；若每次计算器从当前设备开始计，则每个设备的优先级**相同**。  
【**总线分布仲裁**】不需要中央控制部件，各潜在设备都有自己的仲裁号和仲裁器。

## **4.规格化浮点数**

**（1）若阶码为三位，用补码表示；尾数7位，用原码表示，其中一位为符号位；以2为底，则十进制数27／64的浮点规格化数是**   
C．1110110110  
【解析】首先排除A、D，它们非规格化，因为规格化的原码，最高数值位为1。27／64的原码表示：0．0110110=0．110110×2-1。左移一位成规格化数。阶码用补码：111。  
（2）设浮点数的基数为4，尾数用原码表示，则以下（C）是规格化的数。  
A.1.001101   B.0.001101   C.1.011011   D.0.000010  
【解析】规格化规定尾数的绝对值≥1/R（R为基数），并≤1。这题：当基数为4时，尾数绝对值应≥1/4，尾数用原码表示，则小数点后面2位不全为0即为规格化数。  
PS：对于基数为4的原码尾数，每右（或左）移2位，阶码加（或减）1。

![](https://img-blog.csdnimg.cn/2020110509465526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

## **5. 算术左移的溢出**

补码，当数据的最高位和符号位不同时，此时进行算术左移会导致符号的变化，从而超出该数据设定的范围大小（造成溢出）。  
——**等价于**【对某个数据乘2运算相当于对该数据二进制数进行不带符号位左移一位。】  
**【典例1】数位每左移1位相当于原数乘以2，为防止左移操作造成溢出，补码左移的前提条件是：其原最高有效位    **        
A．为0        B．为1   C．与原符号位相同            D．与原符号位相异              答案: C  
解析: 补码表示时，最高数位为“0”时是有效位、为“1”时是无效位，故算术左移时，最高数位丢“0”，结果出错，而丢“1”，则不对结果产生负面影响。最低数位为“1”时是有效位、为“0”时是无效位，故算术右移时，最低数位丢“1”，影响精度，而丢“0”，则不对结果产生负面影响。

**【典例2】某字长为8 位的计算机中，已知整型变量 x、 y 的机器数分别为[x]补=1 1110100， [y]补=10110000。若整型变量 z=2*x+y/2，则 z 的机器数为（ ）**。  
【常规做法】x的补码算术左移为11101000（因为_x的数据最高位和符号位相同，所以左移没事_），y的补码算术右移为11011000， 两者相加可得111000000。可知符号位产生的进位为1，最高有效位产生的进位也为1，两者相同，则无溢出。 最高一位1丢掉得最终结果11000000。  
【**快速做法**】把补码按位取反加个1，x＝-12，y＝-80，z就等于-64，八位的负数最大为-2的7次方，没有溢出，-64用补码表示就是1100 0000。

【补码从低位到高位找到的第一个1的左边均与反码相同，该1的右边均与原码相同】  
PS（1）：补码左移溢出的判断依据是，当符号位与最高数值位不同时，左移会溢出。  
——举例：补码1011即原码为1101（十进制为-5），而补码左移1位补码变成1110即原码为1010（十进制为-2）；而如果补码1100即原码为1100（十进制为-4），而补码左移1位补码变成1000（十进制为-8）。  
PS（2）：【**逻辑移位**】左移和右移都是空位补0；【**算术移位**】负数补码是左移添0右移添1.

## 6.补码一位乘

**实现N位（不包括符号位）补码一位乘时，乘积为      位（2007年 西安电子科技大学）**  
A．N     B．N+1     C．2N      D．2N+1     答案：D  
解析：补码一位乘法运算过程中一共向右移位N次，加上原先的N位，一共是2N位数值位，因乘积结果加上符号位，故共2N+1位

## 7.主存&CM

 

**主存**

**控制存储器**

**功能**

存放程序和数据

存放微程序

**位置**

在CPU外部

在CPU内部

**成分**

RAM

ROM

控制存储器（只读型存储器ROM——因为每条微指令执行时所发出的控制信号是事先设计好即**不需要改变的**）存放实现指令系统的所有微指令——按照微指令的地址访问，而主存按照主存地址访问。  
CPU不能直接访问控存，控制存储器对软件开发人员是透明的；指令的操作数可以指定的地址只有【寄存器】和【主存】。

![](https://img-blog.csdnimg.cn/20201021110623540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)![](https://img-blog.csdnimg.cn/20201206193810732.png)  
（1）在微指令的**控制字段**中，每一位代表一个【微命令】。  
（2）若用微程序控制方式，不可用μPC代替PC——μPC只是在微程序中指向下一条微指令地址的寄存器，即μPC指出的是同一条指令内的下一个微操作罢了，而不知下一条指令是啥。  
（3）字段直接：互斥性微命令组成的字段表示多条微命令（编码）。——**互斥性命令在同一字段内（一山容二虎），相容性命令在不同段内**。

## 8.地址题

（1）假定用若干个8K*4位芯片组成一个基地址为0的地址连续的64K*8位存储器，则主存地址3020H所在芯片的最小地址是         （中国科学院大学2017年）                B. 2000H   
解析：用3020H除以8K,得到的余数就是所在芯片，再看所在芯片的起始地址即可，根据(64K*8)/(8K*4)=16，需要16块芯片，但是注意片选位不是4位。由于小芯片是8K即13位，存储器为64K即16位，因此前三位用作片选；  
由于64K=2^16（所以地址位数为16），3020H的二进制位为0011 0000 0010 0000，后13位全部取0即可得到该主存地址所在芯片的最小地址 0010 0000 0000 0000，即2000H。【类似题——第39点笔记[39.从地址中找ans](about:reader?url=https%3A%2F%2Fandyguo.blog.csdn.net%2Farticle%2Fdetails%2F104351765#39.%E4%BB%8E%E5%9C%B0%E5%9D%80%E4%B8%AD%E6%89%BEans)】  
（2）某计算机存储器按字节编址，主存地址空间大小为64MB，现用4M×8位的RAM芯片组成32MB的主存储器，则MAR位数至少为——26位。  
【解析】考察存储器的设计。  
64MB需要26位地址，但实际上只插了32位的内存条（25位）即只需要25位地址（实际容量），  
MAR决定主存地址空间（MAR的设计是在做电路设计时就要设计好的），“实际的”是插了多少根内存条，若有剩余位数则可以后再插入内存条，而MAR位数如果一开始确定后面是无法更改的。  
MAR要保证访问到整个主存地址空间，所以应是26位。  
【回忆】RAM芯片字扩展可以增加**存储单元的数量**，位扩展可以增加**存储字长**。

## 9.浮点数

（1）在浮点机中，设尾数采用双符号位，当补码运算结果的尾数部分不是规格化的形式应进行规格化处理，当尾数符号位为          时，需要右规。（哈尔滨工业大学 2007年）  
A．00      B．10      C．11        D．01或10          答案：D  
解析：运算结果两符号位不等，表示尾数之和绝对值大于1，需右规，即将尾数之和向右移一位，阶码加1。

（2）IEEE754浮点数C1E00000表示的真实的数是          （北京科技大学 2013年）  
A. -7B. -28C. -14D. 14       答案：B  
解析：(1 1000 0011 110 0000 0000 0000 0000 0000)2  
符号S=1为负；指数用移码表示：1000 0011，即131-127=4；  
尾数为110 0000 0000 0000 0000 0000 B；即完整的基数为1.11。指数为4，即小数点右移4位，为11100。  
(11100)2=(0001 1100)2=(1C)16=(16+12)10=(28)10【注此处要将原码补充完整为8位，前面填充0】又符号位为负，所以最终为-28。

### 注：****符号扩展****

![](https://img-blog.csdnimg.cn/20201101145206872.png)

**正数：填充原符号位（其余为0）；**  
**负数：若原码则填充符号位（其余为0）；若补码/反码则原符号位移到新符号位，其余填充1）。**

## 10.三个时间/周期

****存储周期****：连续启动两次读或写操作所需最小的****间隔时间****。   
****存取时间****：指的是CPU读或写内存内数据的****过程时间****。   
****存储时间****：属于****存取时间****的****存操作****数据的****过程时间****。（注意和存取时间的区分）

### 拓展：

（1）指令字长=存储字长的前提下，取指周期=机器周期（=间址周期=执行周期=中断周期），一个机器周期=k个时钟周期。  
错误选项举例：指令字长=机器（错在机器字长）字长的前提下，取指周期=机器周期。  
这里注意【机器字长】是计算机一次整数运算能处理的机器位数，即运算器ALU位数和通用寄存器宽度；  
通常把一次总线事务访问主存或I/O的时间定为一个【机器周期】——【存储字长】和【指令字长】均和机器字长**没有必然的联系**。

（2）存储字长是指存储体中一个存储单位中的位数，**MDR位数（数据字长）**可与存储字长不同（k倍关系即可）。  
如MDR中的一个16位的二进制数就需要占用两个存储单位的空间。

（3）如果指令字长=2 × 存储字长，则需要2次访存，取指周期=机器周期×2；  
指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数，但是为了**硬件设计方便**，指令字长一般取字节或存储字长的整数倍。  
（4）【读懂题外话】若不采用指令预取技术——则每个指令周期都需要取指令；若不采用Cache技术，则每次取指令都至少访问内存一次（当指令字长与存储字长相等且边界对齐时）。

## 11.五种I/O方式

第一种是****程序查询方法****，依靠CPU不断的执行查询指令（**软件**）等进行数据传输。  
第二种是****中断方式****，通过CPU 执行中断处理程序（**软件**）完成数据的传输，但中断处理需要**硬件**。  
第三种是****DMA 方式****，通过在内存和设备之间开设一条专用的数据通路，通过这个数据通路完成数据的传输，利用**硬件**实现数据传输，在数据传输过程中不需要CPU干预，****传输完毕后，要进行数据校验等工作时****，DMA部件会发出一个中断，请求CPU进行后续工作。  
第四种是通过****通道方式****，DMA方式需要CPU来控制传输的数据块大小、传输的内存位置，而通道方式中这些信息是由通道控制的，通道程序（**软件**）控制数据交换。（每个DMA控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换，总之通道相当于一个弱鸡版CPU。）——通道是**软硬**结合。  
——通道与CPU共享内存，但通道独立于CPU，即有自己的指令系统（只有数据传送指令、设备控制指令）。  
——CPU通过【I/O指令】控制通道，也即一开始CPU要组织1个通道程序&使用I/O指令启动通道，同理I/O操作结束**后**，通道程序向CPU发出【中断响应】。  
第五种是****IO 处理机****。  
其中DMA 是完全依靠**硬件**完成数据的传输；中断和通道是依赖**软件与硬件；**程序查询方式完全采用**软件**实现。  
中断方式中，若准备数据的时间小于中断响应和中断处理的时间，则数据会被刷新，造成丢失。

PS：Cache与主存的地址映射由**硬件**自动完成。

## 12.分段与分页的比较

1

将程序分成固定大小的页

将程序分成不同的段

2

OS负责实现

编译器负责实现

3

速度快

速度比分页慢

4

针对OS

针对用户

5

有内部碎片

有外部碎片

6

逻辑地址分为页号和页内偏移量

逻辑地址分为段号和段偏移量

7

页表

段表

8

页表项拥有一些用于表示页细节的bit

段表项有一些用于保护位。

页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。  
段是信息的逻辑单位。分页的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名[高级语言里编译器会干这件事]。

### 分页管理中：

程序员使用某个内存单元的数据或指令时，需要指定 一维的虚拟地址即可，而这个地址可以通过地址映射映射为物理地址，  
比如 ： CALL 08A5H  
地址映射可以根据页面大小判断出哪部分是页内地址，哪部分是页表中的页号，然后执行。

### 分段管理中：

是将程序分段（比如有堆栈段，数据段等），符合程序员习惯，人们习惯用二维地址描述自己的程序，比如  
MOV BP, [DS]85H 或者 CALL [X][116]  
将 数据段 85H的内容COPY到寄存器BP中，或者 跳转到 X段 。。。。  
所以说它是二维的，**段名和段内地址**。与所谓的“页号+页内地址”不是一个事。

### 综上：

在页表中找一个虚地址，你只要给一个地址，我就能算出来在哪一页，页偏移多少，所以是一维的（只要一个地址即可）  
在段表中找一个虚地址，看上去给的也只有一个虚地址就能找到，但是，其实，这个虚地址是段号和段内偏移这两个地址放在一起合成的，是2个地址（这儿和页不同，页的页号和页内偏移可以自己计算，所以是1个地址），所以是2维。

## 13.大小端

### 口诀：小端就是0x1234是34 12（以数据的低字节为字地址）

（低字节（LSB）是指1234的34，又叫**最低有效字节——试卷给出的机器数的最右边1B的数**）  
将32位数0x12345678按照低字节为字地址存放，则按字节地址由小到大依次存为         78563412          
解析：每个十六进制数代表4个二进制位，故每两个十六进制数构成一个字节，作为一个存放单位（如78H构成一个存放单位），又采用以低字节地址为字地址（即小端）的存放方式，故由小到大依次存为78 56 34 12。  
大端模式：数据的高字节保存在内存的低地址中，和我们的阅读习惯一致；  
小端模式：数据的高字节保存在内存的高地址中。

## 14.地址译码器&指令译码器

CPU的结构中没有地址译码器。****地址译码器****在主存中。地址译码器的作用就是用来接收CPU 送来的地址信号并对它进行译码，选择与此地址码相对应的存储单元，以便对该单元进行读/写操作。  
注意和指令译码器区分，****指令译码器****是控制器的一部分，属于CPU一部分，仅仅对操作码进行译码。

## 15.ALU细节

ALU只能有一个输入端可与总线相连，另一输入端需通过暂存器与总线相连  
解析：由于ALU是一个组合逻辑电路，故其运算过程中必须保持两个输入端的内容不变，又由于CPU内部采用单总线结构，故为了得到两个不同的操作数，ALU的一个输入端与总线相连，**另一个输入端**需**通过一个寄存器与总线相连**；此外，ALU的输出端也不能直接与内部总线相连，否则其输出又会通过总线反馈到输入端，影响运算结果，故**输出端**需通过一个**暂存器**（用来暂存结果的寄存器）与总线相连。

## 16.计算[x-y]补

（1）已知[x]补，求[-x]补，即[x]补连同**符号位在内**每位取反，末位+1，即可得到[-x]补。  
------------------------上条规则等效于**第25条**：正补码变负补码：如25=0001 1001B(就是将25写成二进制形式)，变成-25的方法是：**将上面的数从右往左看，从第一个1左边的数字起（包括该数字）往左，全部取反（无加1）。**  
（2）[x-y]补=[x+(-y)]补=[x]补+[-y]补，即[x-y]补=[x]补+[-y]补。  
（3）大多数计算机系统都x采用补码表示机器数。  
****补码可方便解决补码数的扩充问题****，因在补码表示中，全1表示-1，所以对负数补码进行扩充，可以直接补符号位，如1001扩充成8位，可以写成11111001,0111扩充成8位，可以写成00000111。

### 例题（1）

某计算机字长为8位，其CPU中有一个8位加法器。已知有符号数x=-69，y=-38，现要在该加法器中完成x-y的运算，则该加法器的两个输入端信息和输入的低位进位信息分别是          。（中国科学院大学 2018）  
C.1011 1011,0010 0101,1    答案: C  
解析: 考察加法器。加法器执行减法操作的过程是将减法转換为加法，且执行补码运算。

X=[-69]10=[-100 0101]2=[1100 0101]原=[1011 1011]补  
Y=[-38]10=[-010 0110]2=[1010 0110]原=[1101 1010]补  
加法器对减法的处理是把减数求反，然后输入端的低位进位信号置1。  
所以加法器的两个输入端的输入信号分别为1011 1011和0010 0101，且低位进位为1。

### 例题（2）

参考2017真题（[https://blog.csdn.net/qq_35812205/article/details/108005393](https://blog.csdn.net/qq_35812205/article/details/108005393)）  
虽然i和n均unsigned型，但这里是cmp指令的计算机内部比较功能，即用到补码加减法运算器。  
总之，无符号数的减法是用补码的【x-y】补=【x】补+【-y】补运算的。

![](https://img-blog.csdnimg.cn/20200816194120122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

### 例题（3）

![](https://img-blog.csdnimg.cn/20200830101343549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

【注意】得到-33和65后，可以直接计算-98的补码（先算98的补码，再根据最右1的左边全取反得到-98的补码）。

## 17.磁盘容量

磁盘存储器格式化容量=每道扇区＊扇区容量＊****总磁道数(柱面数)*****记录面  
物理位置的确定依靠（**柱面号，盘面号/磁头号，盘区号**）  
【典例】若磁盘转速为7200 转/分，平均寻道时间为8ms,每个磁道包含1000 个扇区，则访问一个扇区的平均延迟时间大约是     。（西安电子科技大学 2015年）B.  12.2ms  
解析：****存取时间  =   寻道时间  +   延迟时间  +   传输时间****。存取一个扇区的平均延迟时间为旋转半周的时间，即为(60/7200)/2=4.17ms ，传输时间为**(60/7200)/1000=0.01ms**（此处是将0.008ms四舍五入） ,因此访问一个扇区的平均存取时间为4.17+0.01+8=12.18ms   ，保留一位小数则为12.2ms。  
【延迟时间】磁头定位到**一个扇区**的时间，即旋转半轴的时间；如果题目给出**“磁盘控制器延迟（指最先的磁盘启动时间）”则还要加上这个**。  
【传输时间：先求一圈的时间，一圈(一个磁道)又包含1000个扇区，求的一个扇区对应时间即传输时间】

## 18.Cache容量计算

【原则1】标记阵列中的有效位和标记位(主存字块标记)是一定有的，而一致性维护位（脏位）和替换算法控制位的取舍标准是看题眼，题目中，明确说明了采用写回法，则一定包含一致性维护位，而关于替换算法的词眼题目中未提及，则不予考虑。  
【原则2】****写回法****：当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存。这种方法减少了访存次数，但存在不一致的隐患。每个Cache行必须设置一个标志位（脏位），反映该块是否被CPU修改过，1位修改位即脏位（回写策略，根据脏位判断数据是否更新，若脏位为1则需要写回内存。  
【原则3】组相联映射：组间用直接映射，组内全相联映射。 Cache的组号=主存的块号 **mod** Cache的组数（mod为求余运算）

**（1）假定主存地址为32 位，按字节编址，主存和Cache 之间采用直接映射方式，主存块大小为4 个字，每字32 位，回写，则能存放4K 字数据的Cache 的总容量的位数至少是      148K**   
解析：按字节编址，块大小为4 × 32bit=16B ，则“字块内地址”占4 位；“能存放4K 字数据的Cache ”即Cache 的存储容量为4K 字（注意单位），则Cache共有1K=2^10个Cache 行，则Cache 字块标记占10 位；则主存字块标记占32 - 10 - 4=18 位。   
Cache总容量=data+标记阵列（有效位、标记位、一致性维护位和替换算法控制位）。  
从而每个Cache 行标记项包含18+1+1=20 位，则标记阵列容量为：2^10*20 位=20K 位，存储容量为：4K*32 位=128K 位，则总容量为：128K+20K=148K 位。

**（2）Cache采用什么映射方式？若Cache采用LRU替换算法和回写策略，则Cache每行中除数据、Tag和有效位外，还应有哪些附加位？Cache总容量是多少？**  
【解析】图中看出Cache中每组有2行，因此采用2路组相联映射方式。Cache每行还有1位LRU位（LRU替换算法，注意如：如果是8路组相联则是3位的LRU位）、1位修改位即脏位、有效位。28位物理地址中Tag字段占20位，组索引字段占3位，块内偏移地址占5位，因此Cache共有2^3=8组，****每组2行，每行共有2^5=32B（注意此处和第一题不同，********此题没明确说明数据有多少字，故直接用通过块内地址和组字段计算********）****.   
Cache的总容量=标记+数据=2×8×（20+1+1+1）+8×2×32×8b=558B。

![](https://img-blog.csdnimg.cn/202005032141487.png)

### 求组号的方法

已知Cache容量为16KB（14位），块内地址为5位，则  
（1）直接映射则中间的【组号】为（14-5=9位）  
（2）8路组相联映射则中间的【组号】为16KB /(8×2^5B)=2^6，即【组号】6位。  
PS：一般求Cache总容量时，若是组相联，组号只能得出组数信息，注意还要根据每组有多少个Cache（即几路组相联），从而相乘得到Cache的总行数，不要误以为组数即Cache行数（每个Cahce有一份标记，而不是每组）。

## 19.硬布线&微程序

微程序控制器

硬布线控制器

工作原理

微操作控制信号以微程序的实行存放在控制存储器中，执行指令时独处即可。

微操作控制信号由组合逻辑电路根据当前指令码、状态和时序，即使产生。

执行速度

慢

快

规整性

较规整

繁琐、不规整

应用场所

CISC CPU

RISC CPU

易扩充性

易扩充修改

困难

RISC的目标是减少指令数（选择常用的、寄存器型的指令，并不是为了兼容CISC）；RISC的复杂指令是通过简单指令的组合实现的。  
RISC各种指令绝大多数在一个机器周期内完成。  
一句话记忆：**CISC（compose复杂），所以指令长、执行久、难优化编译实现，另外它是微程序——所以易扩充修改。**

### 相关结论：

（1）若指令系统中具有n种机器指令，则**控制存储器中的微程序数**至少是n+2个（增加的1个为公共的取指微程序，另1个为对应中断周期的微程序）  
（2）若要求只有Load/Store指令才能对操作数进行存储访问取指令、取操作数（操作简化&时间长度固定）——简化流水线复杂度。。  
（3）一条机器指令对应一段微程序，一段微程序就是一系列微指令（下图，结合第6点笔记）。

![](https://img-blog.csdnimg.cn/20201021110623540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

## 20.DRAM

DRAM 动态随机存取存储器（****Dynamic**** Random Access Memory，DRAM）随机存取存储器，要电容经常周期性地充电（按行刷新~所以行数越少越好,一次完整的刷新过程只需要占用**1个存取周期**），否则无法确保记忆长存。由于这种需要定时刷新的特性，因此被称为****“动态”存储器****。  
“静态”存储器只要存入数据后，不刷新也不会丢失记忆。  
（1）DRAM采用【地址复用】  
——指地址信号分2行、列2次传送。如4M×8位的DRAM芯片，地址线是原来（log 4M）=22根的一半即11。  
（2）DRAM芯片存储阵列的行数r=32，列数c=64【**意味着**】地址线需要6根(取行或列所需地址线的max)。  
（3）1024×8位的DRAM，地址线为(1/2)log1024=5；  
——问总引脚数：5+8+4（4：行通选、列通选+读/写控制线。读写控制线可1可2）

### DRAM应用于：主机内存；SRAM应用于Cache。

【RAM】DRAM和SRAM都是随机存储器（**断电后信息丢失**）；但SRAM是**非破坏性读出**（无需刷新），注意如果说RAM都是非破坏性读出则错（DRAM是破坏性读出）。  
【ROM】FLASH同时具有ROM和RAM特性（Flash属于只读存储器ROM，但又可以随时改写其中的信息——相当于RAM）  
![](https://img-blog.csdnimg.cn/20200915194018705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)  
按存取方式分为随机存储器RAM、只读存储器ROM——（RAM&ROM都是支持【随机存取】，但注意只读存储器ROM是只能随机读出而不能写入）、  
串行访问存储器，即第三种——串行访问分**顺序存取**存储器（如磁带）与**直接存取**存储器（如磁盘）  
（可和OS的直接存取存储器即磁盘、随机存储的RAM&ROM、顺序存取的磁带等结合复习  
[https://blog.csdn.net/qq_35812205/article/details/105870386](https://blog.csdn.net/qq_35812205/article/details/105870386)）

## 21.中断屏蔽字

1级中断的屏蔽字为1101，代表它可以屏蔽除3之外的其他所有中断

## 22.十进制数转IEEE754短浮点数

将十进制数-0.75转换为IEEE754的单精度浮点数格式表示。

【解析】![](https://img-blog.csdnimg.cn/20200620154820958.png)

注意上图中的**【126】是写出其二进制**。（这里要搞清楚移码和真值相差127）  
![](https://img-blog.csdnimg.cn/20200620155416699.png)

### 短浮点数的规定：

（阶码中0和255都是非正规阶码即（1）（2）（4）（5）点）  
（1）E=0且M=0，则真值为0  
（2）E=0且M≠0，为非规格化数，真值=（-1）^s × 0.M×2^(-126)  
阶码部分表示为0-127+1=-126（注意这里要+1）；尾数部分隐含的数为0，即尾数为0.xxxx  
（3）**1≤E≤254**时，真值=(-1)^s ×1.M×2^(E-127)【“正常”情况float】  
——E的最大正常值为254，若****尾数部分舍入后阶码加1，则最大的阶码为254-1-127=126.（第五问：使得结果不溢出的最大n****[https://andyguo.blog.csdn.net/article/details/106973174](https://andyguo.blog.csdn.net/article/details/106973174)****）****  
（4）E=255且M≠0时，真值为"NaN"(非数值)  
（5）E=255且M=0时，真值为正无穷或负无穷（看符号位）

PS：非规格化浮点数参考（[https://blog.csdn.net/i6223671/article/details/88312191](https://blog.csdn.net/i6223671/article/details/88312191)）

![](https://img-blog.csdnimg.cn/20201009205200579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

## 23.进/借位标志CF(记)

进位位CF（Carry Flag）与溢出位OF（Overflow Flag）

【**求A+B时，进位输出为1——即两个最高位相加向上形成进位，则CF=1;进位输出为0则CF=0**】  
拓展：当两个无符号数相乘（**umul**）时，若乘积的高一半为0，则CF=OF=0；  
当两个带符号数相乘（**imul**）时，若乘积的高一半是低一半的符号扩展，则CF=OF=0.（见第35点IMUL笔记）  
【**求A-B时，进位输出为1则CF=0;进位输出为0则CF=1**】  
【2017年408】无符号数，在补码加减法运算器中执行“0减FFFF FFFFH”，即0000 0000H + 0000 0000H +1=0000 0001H，  
由于进位输出C=0，所以减法运算时的借位标志CF=C 异或 1=1  
【2013年408】“无符号数比较小于等于时转移”功能的指令中，要检测CF、零标志位ZF，不涉及符号标志NF（因为是无符号数）。  
【2018年408】减法指令“sub R1,R2,R3”的功能为“(R1)-(R2)->(R3)”,(R1)=FFFF FFFFH,(R2)=FFFF FFF0H,则该减法指令执行后，CF=0  [x]补-[y]补=[x]补+[-y]补，[-R2]补=0000 0010H，[R1]补+[-R2]补 相加的结果，**减法操作只需判断借位标志，进位输出为1则CF=0，**R1大于R2，所以借位标志CF为0（PS:wd真题解析只说了绿色字体）。

！！注意：408真题中常考无符号数，而如果是有符号数A-B时（像下面典例2），则只用看进位位确定CF。  
----------------------------------------------------------------------------------------  
溢出标志位OF为1时，表示溢出，说明寄存器中的内容不是真正的结果；  
符号标志位SF为0时，表示结果为正数（溢出标志为1，说明符号标志有错）；  
进位标志位CF为1，仅表示加法器最高位有进位，对运算结果不说明什么。

### 经典例题（1）（408真题）

![](https://img-blog.csdnimg.cn/20200720160210409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

（1）错误思路：认为a-b，a大于b时结果的符号标志SF=0且零标志ZF=0，所以选B。但实际因为若溢出标志为1，说明符号标志有错。  
（2）这里的A大于B，就像下图的5-3（补码形式，[x-y]补=[x]补+[-y]补，可结合第16点复习）一样，其实**进位输出是1**（注意不要理解成十进制那种大数-小数“没有进位”）所以CF=0。

![](https://img-blog.csdnimg.cn/20200720155949341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

### 经典例题（2）

2个整数x和y，x=-68，y=-80，用补码（含1位符号位）表示，x和y分别存放在寄存器A和B中。还有2个寄存器C和D。A,B,C,D都是8位的寄存器.  
**（1）寄存器A和B的内容分别是什么？**  
【解析】x=-69=-100 0100,则[-68]补=1011 1100=BCH,因为y=-80=-101 0000，则[-80]补=1011 0000=B0H，寄存器A和B中的内容分别是BCH,B0H  
**（2）x和y相加后的结果存放在寄存器C中，寄存器C中的内容是什么？**  
【解析】[x+y]补=[x]补+[y]补=1011 1100 +1011 0000=1 0110 1100=6CH，所以寄存器C中的内容是6CH,其真值为108.此时溢出标志位为1，表示溢出，即说明寄存器C中的内容不是真正的结果；符号标志位SF为0，表示结果为正数（****溢出标志位1，说明符号标志有错****）；进位标志位CF为1，仅表示加法器最高位有进位，对运算结果不说明什么。  
**（3）x和y相减后的结果存放在寄存器D中，寄存器D中的内容是什么？此时溢出标志位OF是什么？符号标志位SF是什么？进位标志位CF是什么？**  
【解析】[x-y]补=[x]补+[-y]补=1011 1100 +0101 0000=1 0000 1100=0CH，最高位前面的一位被丢弃（取模运算），结果为12，所以寄存器D中的内容是0CH，其真值为12.此时溢出标志位OF为0，表示不溢出，即寄存器D中的内容是真正的结果；符号标志位SF为0，表示结果为正数；进位标志位CF为1，仅表示加法器最高位有进位，对运算结果不说明什么。  
   1011 1100  
   1011 0000  
1  0110 1100（最前面进位的1即CF位，注意两个加数为有符号数；第二位为SF位）  
注：产生进位不一定代表溢出。（第三小问就是一个典型例子）

## 24.求程序代码总容量

题：已知一段程序首行代码虚拟地址为 0040 1020 H，其机器指令为55 4D F4;最后一行代码的虚拟地址为0040 107F,其机器指令为 C3 D4 58 ,求程序代码总容量。  
正解：0040 107F H +2 - 0040 1020 H +1 =0000 0062 H=98B  
错解：0040 107F H - 0040 1020 H +1 =0000 0062 H=96B

## 25.正补码变负补码

假设寄存器为8位，用补码形式存储机器数，包括一位符号位，那么十进制数-25在寄存器表示为：          （杭州电子科技大学 2012年）D. E7H   答案：D  
解析：25=0001 1001B(就是将25写成二进制形式)，变成-25的方法是：**将上面的数从右往左看，从第一个1左边的数字起（包括该数字）往左，全部取反**。对0001 1001B，从右往左看，第一位是1，不变；从第二位起（包括该位）往左，全部取反，就变成了1110 0111B，即E7H。  
PS：负补码变正补码也是同样方法。

### 法一：第一个1左取反

不管正数变负数还是负数变正数，都是从低位到高位，从第一个1左边一律取反，得到相反数。如-43，由于43二进制是0010 1011，则-43位1101 0101.

### 法二：将25的0001 1001包括符号位全部取反加1得到-25补码

即常规方法：正数变负数，就是取反+1，负数变正数，就是-1取反。

## 26.交叉编址

![](https://img-blog.csdnimg.cn/20200623174356639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)![](https://img-blog.csdnimg.cn/20200623174356647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/2020110621273639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

低位交叉编址：可通过流水线并行存取，提高存储器带宽  
高位交叉编址：访问一个连续主存块时，总是现在一个模块内访问，等到该模块访问完才转到下一个模块访问，CPU总是按顺序访问存储模块，存储模块不能被并行访问，因而不能提高存储器的吞吐率。  
PS：高位多体交叉存储器虽不能满足程序的连续读取，但仍可能一次连续读出彼此地址相差一个存储体容量的4个字（只是这么读的概率较小）。  
**简单计算题（1）**：一存储器支持四体交叉存取，某程序执行过程中访问地址序列为3,9,17,2,51,37,13,4,8,41,67,10.请问哪些地址访问会发生体冲突？  
【解析】首先将访问地址分别%4得到模块序号。

访问地址

3

9

17

2

51

37

13

4

8

41

67

10

模块序号

3

1

1

2

3

1

1

0

0

1

3

2

**如何判断是否访存冲突**：若相邻的4次访问出现同一个模块序号，则后者和前者访存冲突。  
**简单计算题（2）**：某计算机字长为32位，存储体的存储周期为200ns。采用四体交叉工作，用低2位的地址作为体地址，存储数据按地址顺序存放。主机最快多长时间读出一个数据字？存储器的带宽是多少？  
【解析】因为每个体的存取周期是200ns。四体交叉轮流工作，每2个体间读出操作的延时为1/4个存储周期，理想情况是每个存取周期平均可以读出4个数据字，读出一个数据字的时间平均为200ns/4=50ns.数据字长为32位，数据传输率为32位/50ns=80MB/s  
**真题选择题（3）**：  
某计算机主存按字节编址，由4个64M×8位的DRAM芯片采用交叉编址方式构成，并与宽度为32位的存储器总线相连，主存每次最多读写32位数据。若double型变量x的主存地址为804 001AH，则读取x需要的存储周期是（3）  
【解析】4体低位交叉编址。由于double型变量是8B（64bit），而一个DRAM一次存取8bit，所以读取x要8次DRAM，因为double型变量x的主存地址为804 001AH的最低2位为10（最低2位表示该字节存储的芯片编号），说明它从编号为2的芯片开始存储（从0开始编号），因此至少需要3个存储周期（2,3；0,1,2,3；0,1）。

## 27.指令执行时访存

![](https://img-blog.csdnimg.cn/20200628173939121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

     指令执行过程中需要访问主存时，CPU首先把被访问单位的地址送到MAR中，然后通过地址线（单向）将主存地址送到主存中的地址寄存器，以便**地址译码器**进行译码选中相应单元，同时CPU将读写信号通过控制线送到主存的读写控制电路（见下段）。  
    如果是写操作，那么CPU同时将要写的信息送到MDR中，在读写控制电路的控制下，经数据线（注意是双向的）将信号写入选中的单元；如果是读操作，那么主存读出选中单元的内容送到数据线，然后送到MDR中。

## 28.循环结构的地址变化

数组A[0]首地址为2000H，经过循环结构和变址寻址访问数组A元素，若某次循环所取元素为2100H，则此时变址寄存器内容为（ 32）：**2100H-2000H得到100H，代表地址变化了100H（十六进制）个内存单元**（假设题目为按字节编址），则100H化为十进制256，再用256B/8B=32即现在的数组元素下标。  
常见的数据类型大小：**double（8B）  int（4B）  short（2B）char（1B）**  
注意：有些题目说明就“16位计算机”，那这题的int就是16位而非32位了**（**[https://andyguo.blog.csdn.net/article/details/108290875](https://andyguo.blog.csdn.net/article/details/108290875)**）。  
PS：其实**int字节数跟语言无关，跟机器位长相同，32位机器是4字节，64位机器是8字节。

## 29.接口&端口

【两者联系】接口是主机和外设的交接界面；  
端口指接口电路中可以进行读/写的寄存器，若干端口+相应的控制逻辑=接口。

![](https://img-blog.csdnimg.cn/20200701221427954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

PS：上图（王道的）的地址线疑误（应为单向），下图颜值高点==

![](https://img-blog.csdnimg.cn/20200722215452139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

### （1）关于接口（I/O控制器）

外设和接口一侧的数据传送分为并行接口（一个字节/字的所有位同时传送）&串行接口（一位一位地传送）；另外如果是主机和接口一侧的数据传送则一定是并行传送。  
PS:I/O控制器，又称**I/O接口**，又称**设备控制器**。

### （2）关于端口（寄存器）

指接口电路中可被**CPU直接访问****寄存器**。之所以能被CPU访问是因为有端口地址（统一编址/独立编址）。端口分为数据端口、状态端口和控制端口。  
判断命题：I/O端口中CPU可以访问的寄存器称为**I/O接口**（正确）  
I/O指令实现的数据传送通常发生在（通用寄存器和I/O端口之间）：I/O指令时CPU发出的，而AB选项和CPU没有关系，对于B选项注意CPU和I/O设备工作方式速度不匹配，所以需要有I/O接口作为“中介”。

## 30.总线中的地址线

.系统总线中地址线的功能是用于选择        。（北京科技大学 2014年）  
A．主存单元  B．I/O端口 C．磁盘数据块 D．A或B      答案：D

解析：**地址总线**既可用于****选择主存单元****，也可用于****选择I/O端口****；磁盘通过磁盘控制器与主机相连，故系统总线中的地址线只能用来选择磁盘控制器中的端口，而不能用来选择磁盘数据块。  
（1）间址寻址第一次访存得到的【操作数的有效地址】通过**数据总线**送到CPU。  
（2）突发（猝发）传送是【在一个总线周期内】一次传输一个地址（先）和一批地址连续的数据（后），提高设备的吞吐量。  
（3）接口和外设的状态信息、I/O接口的命令字&I/O接口中的状态字、中断类型号也通过**数据总线**从I/O接口发往CPU。  
**控制总线**包括时序信号、I/O设备和存储器的相应信号等（一般说时钟周期不变，则控制信号不变）。  
（4）控制线和地址线都是**单向**传输，而数据线是**双向**的。  
——指令流是从主存流向控制器（单向），数据流是CPU中的运算器和主存之间流动（双向）。  
啰嗦一句：冯诺依曼机是以运算器为中心，而现代计算机是以存储器为中心。

## 31.判断是地址or数据

CPU判断取出的是**指令**还是**数据**  
指令在取指时，CPU通过访问存储器可将指令取出，在执行时，CPU访问存储器将操作数取出（除了立即寻址是数据由指令的地址码直接给出，其余情况数据均存放在存储器内）。

主存判断信息是**地址**还是**数据**  
总线的类型（地址总线上传输地址，数据总线上传输数据）

【拓展】I/O指令实现的数据传送通常发生在（ ）  
A.I/O设备和I/O端口之间   B.通用寄存器和I/O设备之间  
C.I/O端口和I/O端口之间   D.通用寄存器和I/O端口之间  
【解析】I/O指令是CPU发出的，AC选项和CPU无关，不选。I/O端口是CPU与设备之间的交界面。主机和I/O设备的工作方式和工作速度有很大差异，I/O端口充当“中介”。在执行一条指令时，CPU使用【地址总线】选择所请求的I/O端口，使用【数据总线】在CPU寄存器和端口之间传输数据。  
——————————————  
在统一编址下，访问主存和访问I/O设备是通过不同的地址码来区分的；在独立编址下，则是通过【不同的指令】区分。

## 32.单周期CPU

单CPU中所有指令的指令周期为一个时钟周期（即一个时钟周期内完成一整条指令，即只能把CPU周期拉长，时钟频率降低）。  
单周期CPU要配合多个部件在一个周期内完成一条指令，所以要配合多总线结构（单总线结构不支持并发传送，即只能有一个部件争用总线）；反之，单总线要配合多周期CPU（一个时钟周期内只能完成一个部件的工作，而完成一条指令需要多个部件协调）.  
![](https://img-blog.csdnimg.cn/20201206195845813.png)  
（1）时钟信号不变，控制信号即指PC中操作（每次自动加1即可），所以指令执行中控制信号大体不变。  
（2）时钟频率不会影响到CPI，但可以加快指令的执行速度：若一条指令的执行需要10个时钟周期，则执行这条指令在时钟频率为1GHz的CPU比100MHz的CPU要快。

**附：多周期CPU**  
即一条指令分为多个时钟周期。分为【不定长的机器周期】（耗时短的要向耗时长的阶段看齐即要**满足最慢的**来执行，另一种方法是给短的填充成等长）&【定长的机器周期】。  
**多核CPU**  
多核CPU仍然是指单芯片处理器（“**核心**”：指令部件、算术逻辑部件、寄存器堆和一级/二级的缓存处理单元）；多核之间共享一个统一地址空间。

## 33.校验码

奇偶校验码（指data和校验位两坨中1的个数为奇数的码）只能测出奇数位错误，不能测出偶数位错误。  
【例题】设在数据传送中采用偶校验，若接收到代码为10111011，则表明传送中     
C．未出现错误或出现偶数位错    答案：C  
解析：偶校验只能发现一位错，但不能确定是哪一位错，不能纠错，当码字中出现偶数位错时，码字中“1”的个数仍是偶数，所以不能发现错。题中码字“10111011”中“1”的个数是6为偶数，所以有可能是未出现错误或者出现了偶数位错误。

## 34.溢出判断

****补码浮点数加减法判断溢出****3种方法（口诀：大**同**社会—不溢出）：

1.  采用一位符号位：只要参加操作的2个数符号相同，结果又与原操作数符号不同，则表示结果溢出；
2.  采用双符号位：运算结果的两个符号位相同，表示未溢出。注意此时最高符号位才代表真正的符号。
3.  采用一位符号位（根据**进位情况**）：结果中符号位的进位和最高数位的进位相同，则表示不溢出（若不同则表示溢出）

（**408真题**）减法指令“sub R1,R2,R3”的功能为“(R1)-(R2)->(R3)”,该指令执行后将生成进位/借位标志CF和溢出标志OF。若(R1)=FFFF FFFFH,(R2)=FFFF FFF0H,则该减法指令执行后，CF和OF分别为多少（ ）  
A.CF=0,OF=0     B.CF=1,OF=0     C.CF=0,OF=1      D.CF=1,OF=1   答案：A  
解析：[x]补-[y]补=[x]补+[-y]补，[-R2]补=0000 0010H，[R1]补+[-R2]补 相加的结果中符号位的进位和最高数位的进位相同（若不同则表示溢出），可以判断溢出表示OF为0。  
**减法操作只需判断借位标志**，R1大于R2,所以借位标志CF为0（此处CF可以参照第23点笔记）。

## 35.IMUL&UMUL指令

根据IMUL指令的规定，如果结果的高一半的所有位，与低一半的第一位相同，则OF=CF=0，如果不相同，则OF=CF=1。  
详细参考（[https://zhidao.baidu.com/question/77188082.html?qq-pf-to=pcqq.c2c](https://zhidao.baidu.com/question/77188082.html?qq-pf-to=pcqq.c2c)）

【若乘积的高33位为非全0或非全1，则OF=CF=1】（2019年计组大题第四问考了这个）  
（1）当两个无符号数相乘（**umul**）时，若乘积的高一半为0，则CF=OF=0；  
（2）当两个带符号数相乘（**imul**）时，若乘积的高一半是低一半的符号扩展，则CF=OF=0.  
【2020年408】int型x和y作乘法（x=2^31-1，y=2），n=32，判断imul和umul下是否溢出。

```
unsigned umul ( unsigned x , unsigned y) {return x*y; } int imul ( int x, int y ) { return x * y; }
```

【解析】imul指令和umul指令得到的64位乘积的机器数都是0000 0000 FFFF FFFEH。  
（1）int的表示范围为-2^31到2^31-1，所以函数imul()的结果溢出（即不能正确表示应有的结果——2^32，而机器数解读为负数了），故imul（）结果溢出。  
（2）unsigned int型的表示范围是0到2^32-1，所以umul的结果不溢出。

## 附常用汇编指令：

## 一、数据传送指令

（1）【mov指令】内存和寄存器直接移动data。将第二个操作数（寄存器/内存/常数值）  
（2）【STA指令】把寄存器的内容写入指令的内存单元。如STA X（X为主存地址）：隐含寻址，将ACC内容写入主存X。  
push、pop

## 二、算术&逻辑运算

add、sub、inc/dec（将操作数自加1/自减1）、imul、idiv、and/or/xor、neg、shl/shr

## 三、控制流命令

jmp、jcondition/jle、call/ret(call保存调用之前的地址信息，ret实现子程序的返回机制)  
jle指令（条件转移指令——小于等于时转移）；  
call指令（函数调用指令）；jmp指令（无条件转移指令）；  
ret指令（子程序的返回指令），后三条一定会跳转。

## 36.指令周期执行模板

![](https://img-blog.csdnimg.cn/20200831162307239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

## 37.磁道转圈题

【典例】磁盘每个磁道分成9个块/记录（A~I），转1个记录需要10/9ms  
（1）若记录顺序存放，读完记录后需要2.5ms处理  
【解析】第一部分：每开始读一块至转到【序号连续的下一块】前需要用10/9圈；第二部分：读第9个&处理。  
耗时=10×8×（10/9）+10/9+2.5=92.5ms  
（2）请实现顺序读出，求耗时  
【解析】画图便于理解。转1个记录约1.1ms，刚好转3个才能达到3.3即大于2.5ms，所以间隔3个放。

![](https://img-blog.csdnimg.cn/20200902234217476.png)

耗时=40-（3×10/9 -2.5）=39.17ms  
【同理】——每转1个逻辑记录要20/2=2ms，所以T(优)=2ms×3个记录×10次=60ms  
T(初)=（8+3）/10圈×前9个+最后一个记录用3/10圈=102/10圈，即204ms，最后204-60=144ms。  
![](https://img-blog.csdnimg.cn/20201123201211850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

## 38.data类型转换

数据类型的转换

转换原则

同一类型但字长不同的数据间的转换（如int和long）

由字长短的转为字长长的

定点数与浮点数之间的转换

由**定点数**转换为**浮点数**

整型数中的有符号数和无符号数间的转换

机器数不变（只是看待符号位的角度不同，代表的数值也随之不同）

【**混合运算原则**】类型提升：char（1B）->int（4B）->long(4B)->float->double（8B）.  
【举例】float要转成double才能和double型运算（最后结果也是double）——该转换由系统自行进行（隐式类型转换）。  
【典例】int i=785，float f=1.5678e3 ，double d=1.5e100，（d+f）-d==f的结果不为真；i==(int)(float)i的结果为真  
【解析】浮点运算d+f需要对阶（小阶向大阶对齐），对阶后f的尾数有效位被舍去而变为0，所以**d+f的结果仍然为d**，再减去d后结果为0，故结果不真.  
int是精确到32位的整数，float只保存到1+23位，所以int转成float可能损失（虽然不会发生溢出，由于尾数位数原因，可能有数据舍入，而转换为double则能保留精度），但i=785即小于10位（1024）所以不会又损失。  
PS：int的a和b——(float)(a+b)/2是先float强制类型转换后再除2（**注意运算优先级**）。

## 39.从地址中找ans

（1）2010年第二问[https://blog.csdn.net/qq_35812205/article/details/107786209](https://blog.csdn.net/qq_35812205/article/details/107786209)  
（2）与（1）真题类似的王道模拟题：  
【原题背景】2路组，每个主存块=8B，一个元素=32位=4B，即一个组有2个Cache行。  
【第一步】根据映射方式将映射到Cache的2个行中对应的主存地址画表格（如下）；  
——PS：看清楚题设：数组元素是**按行存放**还是按列存放。  
【第二步】由第一步的地址确定x和y数组元素映射到哪个Cahce中；特别注意这里**组相联中，组号=主存块号 ÷ Cache的组数，因此不要以为第一组是放0~31**。  
【第三步】确定程序的元素访问次序；  
【第四步】一般问命中率，注意直接映射和组相联映射的替换Cache略不同（组相联映射中，如果同组的Cache未满，则利用空闲Cache，而不需将其他Cache调出）。  
![](https://img-blog.csdnimg.cn/20201110224742110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)  
（3）**芯片题**  
【2010年408】用若干2K×4位芯片组成一个8K×8位的存储器，则地址0B1FH所在芯片的最小地址为（ ）  
【法一】共需要（8K×8）/（2K×4）=8，即每行需要2个芯片，每列需要4个芯片。  
第一行：0000H~07FFH;第二行：0800H~0FFFH（举例求07FF：2个芯片共2KB=2^11即1000 0000 0000-1=07FF）  
第三行：1000H~17FFH;第四行：1800H~1FFFH  
【**法二**】组成8K×8位，由8K知道地址是13位（0 1011 0001 1111），由2K×4位的2K知道地址是11位，13-11=2位作为大芯片的片选位。  
容量较小的芯片对应的内部地址是后面的11位，而前2位（红色）起着片选的效果，注意由于每行的2个芯片共用一个16位地址，所以片选的是“2个2个选”，也即这类题目说的所在芯片是“大芯片”。把除前2位外其余为0（操作类似求网络号），即0 1000 0000 0000，即0800H。

## 40.struct的边界对齐

【**存储对齐的重要条件**】  
（1）每个成员按其类型的方式对齐，char的对齐值为1，short为2，int为4（单位均为B字节）；  
存放起始地址%该成员长度=0。  
（2）struct长度必须是成员中最大的对齐值的整数倍（不够就补空字节），以便在处理数组时保证每一项都边界对齐。  
【前提】以下栗子均是按字节编址。  
【分析】若N为对齐值，则该成员的“存放起始地址%N=0”，而结构体中的成员都是按定义的先后顺序排放的。  
【实例1】设**B结构体**从地址0x0000开始，第一个成员b的对齐值是1（char是1B），所以其存放地址0x0000符合0x0000%1=0；第二个成员a的对齐值是4（int是4B），如果放在0x0002，2不能被4整除（**注意不是看2能否被4整除，而是看2H**），不行（不能保证边界对齐），  
只能存放在0x0004到0x0007这4个连续的字节中，满足0x0004%4=0且紧邻第一个成员；  
第三个成员c的对齐值是2，可以存放在0x0008到0x0009这2个字节中，满足0x0008%2=0且紧邻第二个成员。  
结构体长度必须是最大对齐值（此处为4）的整数倍，故0x000A到0x000B也为B所占用，共**12B**。

```
struct A{int a;char b;short c;}struct B{char b;int a;short c;}
```

【实例2】设A**结构体**从地址0x0000开始，第一个成员a的对齐值是4（int是4B），所以其存放在0x0000到0x0003这4个连续字节；第二个成员b的对齐值是1（char是1B），存放在0x0004中，满足0x0004%4=0且紧邻第一个成员；第三个成员c的对齐值是2，可以存放在0x0006到0x0007这2个字节中，满足0x0006%2=0且紧邻第二个成员。  
结构体长度必须是最大对齐值（此处为4）的整数倍，故占用0x0000到0x0007，共**8B**。  
【结果】sizeof（A）=8；sizeof（B）=12。  
【注意】**double（8B）  int（4B）  short（2B）char（1B）。**

## **41.USB**

USB是**串行总线**，不能同时传输2位数据；USB属于设备总线标准（设备与设备控制器之间的接口）。  
而PCI、AGP、PCI-E是局部总线标准（连接主存、网卡、视频卡等）。

### 附常考英文词汇：

PCI（外部设备互联）——即插即用的局部总线，可通过桥实现多层PCI总线；  
————PCI总线与CPU及时钟频率都无关，PCI即插即用，可对数据和地址进行奇偶校验，用猝发传送方式；总线中有多条PCI总线。  
AGP（加速图形接口）——连接主存和图形存储器，局部总线  
ISA（最早出现的系统总线）

## 42.无符号数的溢出

当运算结果超过n位数时就可能发生溢出，而舍弃高位有2种情况：

（1）剩下的低n位数不能正确表示运算结果：  
结果超出计算机能表示范围，有效数值进到第n+1位【称为**溢出**】；  
如4位无符号数14+3（1110+0011=10001），结果中第一位1是数值部分，丢了结果就不对了。

（2）剩下的低n位数能正确表达计算结果：  
高位的舍去不影响运算结果；  
如4位无符号数减法运算，14-3时用14加-3的补码实现（1110+1101=11011），结果中第一位1不是数值部分，丢弃后为1011即十进制11，结果正确。

![](https://img-blog.csdnimg.cn/20200916233533744.png)

## 43.多个CPI

![](https://img-blog.csdnimg.cn/20200917231626186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200917231700775.png)

平均CPI即这四种指令的**数学期望**。  
【**错误解法**】取CPI的倒数——每个时钟周期能执行的指令条数ni，再分别乘概率累加。

## 44.断定方式

直接由微指令的**下地址字段**指出【后继微地址】，如整个系统中有微指令128条，则【下地址字段】需要7位——才能寻址到这128条微指令。  
另一种方法【操作码】机器指令将OP取至IR后，OP经 微地址形成部件 形成微命令的地址。  
若采用微操作，则在每条指令之间加入 **Ad(CMDR)->CMAR；**  
最后一条指令后加上 **OP(IR)->微操作数形成部件->CMAR。**

[https://blog.csdn.net/qq_35812205/article/details/107620819](https://blog.csdn.net/qq_35812205/article/details/107620819)

## 45.两种基址寻址

![](https://img-blog.csdnimg.cn/2020092115582941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

（1）【寻址特征】又叫【寻址方式位】，如1条指令源操作数和目的操作数分别采用直接寻址和基址寻址则有2位寻址方式位，而非1位。该指令格式如下：

OP

寻址特征位

源寄存器编号1

源寄存器编号2

目的偏移量A

（2）如若共16个通用寄存器，则R0有4位。  
（3）寄存器寻址——操作数在**寄存器**；寄存器间接寻址——操作数在**主存**。  
典型真题：[https://blog.csdn.net/qq_35812205/article/details/108312417](https://blog.csdn.net/qq_35812205/article/details/108312417)

![](https://img-blog.csdnimg.cn/20201101073159191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

## 46.PC/MAR/IR位数

（1）PC和MAR都是存放访存的地址：PC给出下一条指令字的访存地址，取决于存储器的字数，存储单元个数。  
【栗子】主存为4GB，字长为32位，按字节编址，32位字长指令字，求PC位数。  
【误区】以为PC位数=指令字长位数。  
【解析】存储器的存储单元个数=4GB/32bit=2^30，即字数为30位，PC=30位。  
（2）指令多少位IR就多少位。  
【注意】指令总是根据PC从主存中取出（无论是中断返回指令还是无条件指令——只是简单地将跳转地址覆盖原来PC的内容）。——2[019年指令大题第二问转移指令](https://blog.csdn.net/qq_35812205/article/details/107959350?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160421673019725255520856%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=160421673019725255520856&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-1-107959350.pc_v1_rank_blog_v1&utm_term=%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB&spm=1018.2118.3001.4450)

## 47.中断时间轴

【**传送数据的时间**】【**占用CPU的时间**】（[https://blog.csdn.net/qq_35812205/article/details/108133897](https://blog.csdn.net/qq_35812205/article/details/108133897)）

![](https://img-blog.csdnimg.cn/20200821161313801.png)

【上图内涵】CPU启动外设A，A接收启动命令到A将字符送入I/O端口【用时0.5ms】，I/O端口每收到1个字符申请一次中断，中断响应10个时钟周期。之后CPU运行中断服务程序【共用时20条指令】——前15条干正事，后5条是CPU**启动下一次操作**（和前面传送基本无关，CPU和外设并行）。  
一句话，以【启动】为界限分割每个周期；这类题目问的时间时注意**是否是问几个时钟周期；  
另外求CPU用时，除了中断服务程序时间，不要漏了请求响应的时间**。

![](https://img-blog.csdnimg.cn/20200822160916867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200929205426205.png)

## 48.主存块号&Cache块号

**主存块号**=主存地址中**除了字块内地址外**的部分，即下图中在主存右边标出的编号。  
拆分方法：如果是二进制就数“高位”；如果是十进制（用**主存地址÷块大小=主存块号``````字块内地址**），本质方法都一样，二进制除法就是移位。    
主存块号 ÷ Cache块数 = 主存字块标记``````Cache块号（**可以应用2010真题**[https://blog.csdn.net/qq_35812205/article/details/107786209](https://blog.csdn.net/qq_35812205/article/details/107786209)**第二问**）  
PS：注意题目说的是主存块号还是Cache块号（如2016年真题第二问[https://blog.csdn.net/qq_35812205/article/details/107915170](https://blog.csdn.net/qq_35812205/article/details/107915170)题目直接说“块号为4099的主存块”，那4099就是主存块号=TAG+Cache块号，**一定注意不包括块内偏移**）。

![](https://img-blog.csdnimg.cn/20200805184951135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

## 49.时间&空间局部性

时间：一条被执行的**指令**，不久后该**指令**可能再次被执行。  
空间：一个**存储单元**被访问，附近的存储单元可能很快被访问。

## 50.相对、基址、变址

———变址寻址【慢于】寄存器一次间接寻址（变址寻址访问寄存器IX后，还要将A和(IX)相加——运算需要时间）。  
———一次间接寻址【慢于】寄存器一次间接寻址，因为需要2次访存得到地址，而后者只需要1次。  
———堆栈寻址可能是【硬堆栈】（寄存器）或【软堆栈】（内存）；软堆栈【**慢于**】寄存器寻址。

### **（1）相对寻址**（应用：转移指令）

EA=(PC)+A（A是当前指令地址的位移量，也只有相对寻址是相对于**本指令地址**进行上下浮动）。EA非固定，随PC变化，便于**程序浮动**。  
举例：跳转指令地址为X，占2B，当CPU从存储器中取出该指令后，(PC)=X+2,在完成该指令后会自动跳转到X+2+A的地址继续执行。

### （2）基址寻址（多道程序，浮动程序）

EA=(BR)+A，基址寄存器BR内容由OS确定；A才是偏移量。  
——可以复习第45点笔记两种基址寻址方式。

### （3）变址寻址（处理数组，循环程序）

EA=(IX)+A，**变址寄存器可由用户改变**，A不变（作起始地址）；(IX)才是偏移量。  
相比之下，假设循环程序的数组是基址寻址，则需要很多条指令（每条指令一个偏移量A），所以变址这时就基址牛逼了。

## 51.超标量流水线

【定义】一个时钟周期内可以同时运行多条指令；  
超流水线技术：一个时钟周期内一个功能部件使用多次。

![](https://img-blog.csdnimg.cn/20201002155329798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

注意：流水线功能段的处理时间不变。  
【408真题】若某计算机最复杂指令的执行需要完成5个子功能，分别由功能部件A~E实现，各功能部件所需时间分别为80ps、50ps、50ps、70ps和50ps，采用流水线方式执行指令，流水线寄存器延时为20ps，则CPU时钟周期至少是（100ps）  
【解析】时钟周期以流水线各功能段的最长执行时间为准，题中指令流水线的指令需要用到A~E五个部件，所以每个流水段时间应取最大部件时间80ps，此外还有**寄存器延时20ps**，则CPU时钟周期至少是100ps。  
指令的四个周期是：**取指、间址、执行和中断周期（4个机器周期）。**

## 52.OFFSET

【2019年408】OFFSET=目标地址-（PC+5）=0040 1000H-（0040 1025+5H）=FFFF FFD6H，  
-2A即-42，然后求-42的补码为FFFF FFD6。

【2013年408】首先要将指令中最右边的8位（OFFSET）11100011即E3H进行**符号扩展（负数补码，填充1）**变成FFE3H，再代入题目的转移目标地址公式：（PC）+2+2 × OFFSET。

【2010年408】此题相对寻址不是平时简单的“EA=（PC）+A，（A指指令上的偏移量offest）”  
——此处的偏移量位数确定：此题的表格**最右下角可以看出是(PC)+(Rn)，而Rn在表格首行有说是寄存器**。

【2014年408】求**bne指令的OFFSET字段值  
已知bne指令采用相对寻址方式，当前PC内容为bne指令地址，bne指令的转移目标地址计算公式。**  
bne指令的机器代码后2B的内容：OFFSET=FFFAH（补码），真值为-6。  
快法：FFFAH+0006H=(1)0000H，故FFFAH对应真值为-6.

【转移指令转移地址】****目的地址=(PC)+********指令字长********+k×OFFSET（OFFSET≠总偏移量）****  
系统执行到bne指令时，PC的内容为0804 8118H，而跳转的目标是0804 8100H，两者相差了18H（即24个单位）的地址间隔  
**24的计算过程：**因为0804 8100H=0804 8114H+4(个地址单位)+k×(-6)  
所以k×(-6)=08048100H - 08048118H=-18H=-(1×16^1+8×16^0)=-24，即k=4  
偏移地址的一位即是真实跳转地址的-24/-6=4位。  
所以：bne指令的转移目标地址=(PC)+4+OFFSET×4（此处的OFFSET代表要偏移的指令的数量）

【**错法**】由于要先求0804 8100H - 0804 8118H，这里的地址是无符号数，且计算机求无符号数的减法是x+【y补】，所以就先求0804 8118H的补码（数）  
【**错因**】（无符号数的减法理解没错，站在人理解角度也是用8100H减8118H，但是这里的目标地址是“结果”，即在计算机内部是****(PC)+********指令字长********+k×OFFSET****去求得目的地址的）

## 53.周期挪用(窃取)

【**单字传送方式**】每个字传送完后CPU可以访问主存，  
——如**周期挪用**由DMA控制器挪用k个主存周期来访问主存，传送完一个数据字后立即释放总线。  
【**单块传送方式**】停止CPU访存是在整个数据块的传送过程中，彻底让CPU脱离总线（停止访问主存）  
DMA传送方式注意折中类型的【周期窃取】，其实质是“**CPU不在访存时，I/O设备便占用**”。  
![](https://img-blog.csdnimg.cn/20200417211253196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)  
【2020年408】若设备采用周期挪用 DMA 方式进行输入输出，每次 DMA 传送的数据块大小为 512字节，相应的 I/O 接口中有一个 32 位数数据缓冲寄存器，对于数据输入过程，下列叙述中错误的是：C  
A、每准备好 32 位数据，DMA 控制器就发出一次总线请求；  
B、相对于 CPU，DMA 控制器的总线使用权的优先级更高；  
C、在整个数据块的传送过过程中，CPU 不可以访问主存储器；  
D、数据块传送结束时，会产生“DMA 传送结束”的中断请求。  
【解析】由数据缓冲寄存器位数知道，这里的上面说的一个数据字即32位的数据；  
周期窃取CPU的一个或多个存取周期，而一个DMA传送的数据块大小为512B=512/4个字，即在整个块的传送过程中，传送完一个字后释放总线【单字传送方式】。  
相比之下，【****停止CPU访存****】是在整个数据块的传送过程中，彻底让CPU脱离总线（停止访问主存）。  
【注意】这里的A是正确的！！！！。

![](https://img-blog.csdnimg.cn/2020082218483536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

## 54.2处替换算法

（1）OS在虚拟地址转换中访问页表，若缺页且内存无空闲页框则利用替换算法置换页面。

![](https://img-blog.csdnimg.cn/20200811192451695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

（2）CPU发出主存地址（物理地址）后，  
判断该存储字是否在内存中：  
——若命中则直接根据块内地址，访问块内相应内容；  
——若不命中，则  
———（1）访存，将该【字】传送给CPU；  
【CPU和Cache都和主存建立了直接访问的通路】  
———（2）要将该字所在的主存块装入Cache（如果此时Cache已装满，就用替换算法腾出空位才能调入新的主存块）。  
【当Cache不命中后，CPU直接访问主存拿到数据，不需要调入后再次访问需要的数据】

## 55.Cache访问效率

【Cache的命中率】CPU欲访问的信息已经在Cache中的比率；  
PS：默认为Cache和主存同时访问。  
【第一步】设一个程序执行期间，Cache的总命中次数为Nc，访问主存的总次数为Nm，  
则【Cache的命中率】H=Nc/（Nc+Nm）  
【第二步】设tc为命中时Cache的访问时间，tm为未命中时的访问时间，则Cache-主存系统的平均访问时间Ta=Htc+（1-H）tm  
【第三步】Cache系统的访问效率e=tc/Ta  
【典例】CPU 执行一段程序时， cache 完成存取的次数为5000次，主存完成存取的次数为200次。已知 cache 存取周期为40 ns ，主存存取周期为160 ns 。求：  
1．Cache 命中率 H ，2．平均访问时间 Ta，3．Cache /主存系统的访问效率 e 。【答案26/29】

注意：看清题目是否求指令Cache的命中率：  
【2014年408】指令 Cache 的命中率为：(1000×6-1)/(1000×6)=99.98%。 ——**一定注意要乘6,（每次循环要读6条指令，每读一条指令都要访Cache一次）**。  
[https://andyguo.blog.csdn.net/article/details/106559830](https://andyguo.blog.csdn.net/article/details/106559830)  
指令Cache和数据Cache分离后的数据Cache=标记阵列+数据（而不是只有数据），而此题并没给出主存和Cache的映射关系，所以标记阵列不用求，另外数据区这里指指令Cahce+数据Cache。

## 56.动态重定向

注意：【分页分段】虽然是一次性将作业全部装入内存，【静态重定向】是作业装入时一次性分配所有的内存空间，但**分页属于动态重定向**——页式存储不是像固定分区分配（静态重定向）是用连续空间，即分页的作业一次性装入是离散地装入，因而要把相邻逻辑地址映射到不同物理地址要用到动态重定位。  
![](https://img-blog.csdnimg.cn/20201123212347193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)

## 57.RAW

WAR读后写相关的例子：  
I1： STA M,R2  (R2)->M，M为主存单元；  
I2： ADD R2,R4,R5;  (R4)+(R5)->R2;

RAW（read after writing）写后读。（直接上av画质题）  
![](https://img-blog.csdnimg.cn/20201201205015991.png)  
![](https://img-blog.csdnimg.cn/20201201205016612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODEyMjA1,size_16,color_FFFFFF,t_70)  
详细流水线复习回顾（[https://andyguo.blog.csdn.net/article/details/106559830](https://andyguo.blog.csdn.net/article/details/106559830)）  
【写后读RAW】字面理解应该是先写入再读取，而现在是没有写入就已经读了（即读了旧数据），出错。

## 58.有效控制信号

（1）一般在问节拍安排时一起要写，简单的如R1out,MARin，特别注意涉及内存的，如M（MAR）->MDR对应是**MemR**,**MDRinE**这种（具体细节看题目）——MenR是要读主存相应数据，MenW是写入主存相应位置，括号内即为写入地。  
（典例2009[https://andyguo.blog.csdn.net/article/details/106933503](https://andyguo.blog.csdn.net/article/details/106933503)）  
（2）如加法运算完的有效控制信号要另外加上“add”，还有一些易错点：  
（3）09那题一开始没有将（R1）放入MAR，而错误将ad(IR)送入MAR——这样做的**前提**是取的指令的格式是【直接寻址】，即指令的地址码是【操作数的地址】。（顺便可复习下——如果是**立即寻址**，指令的地址码则是操作数，操作姿势：取指后，**ad(IR)->**R1，如果后面是ACC和(R1)相加则(ACC)+(R1)->R2，；  
如果是**寄存器间接寻址**，则寄存器里存放的是主存地址，别漏了送地址到MAR：（R1）->MAR，M(MAR)->MDR）  
（4）没有意识到MAR的内容不变（一直是R1寄存器放的一个内存地址）  
（5）最后存回内存的R1的data忘记先存入MDR  
（6）运算过程不用写出ALU，直接写输入和输出：（R0）+（A）->AC。  
（7）控制信号的顺序写反。

## 59.变长操作数n

![](https://img-blog.csdnimg.cn/20201206190048969.png)  
【最快方法】设有C条单地址（操作数）指令，【（2^8-m）×2^6-C】×2^6=n，解得C即可。

## 60.VRAM

显示器中VRAM的容量=行分辨率×列分辨率×色深。  
【栗子】某计算机的显存容量=8MB，采用2048×1024分辨率，则每个像素最多可以使用的颜色数是（4G）  
【解析】色深=（8M×8b）/（2048×1024）=32位，所以颜色种类=2^32=4G。

## 61.按位与&

若使用二级页表的分页存储管理方式，逻辑地址结构为

页目录号（10位）

页表索引（10位）

页内偏移量（12位）

**设逻辑地址为LA，请分别给出其对应的页目录号和页表索引的表达式。**

页目录号可表示为(((unsigned int)(LA))>>22)& 0x3FF  
页表索引可表示为(((unsigned int)(LA))>>12)& 0x3FF

注：**可用“无符号右移动>>”和“按位与&”操作取出某几个二进制位的值。  
如01101101,00000000右移动——高位用0补齐，右边8位全舍去，LA>>8  
得00000000,01101101，LA>>8  
                     1111 1111  0xFF(按位与&：只有对应位都为1时“与”结果才为1)  
结果是          01101101**

## 62.可见的寄存器

汇编程序员可见：通过汇编程序对某寄存器进行访问。  
（1）可见：PC、通用寄存器组、PSW;  
（2）不可见：IR、MAR、MDR、暂存寄存器。

## 63.返回值

**返回值是根据二进制串(机器数)的解释。**

```
int f1(unsigned n){int sum=1,power;for(unsigned i=0;i<n-1;i++){        power *=2;        sum += power;    }return sum;}
```

问：f(n)=![](https://img-blog.csdnimg.cn/20200626184112903.png)​​​​​  
将f1中的int都改成float，可得到计算f(n)的另一个函数f2，**f1(23)和f2(23)的返回值是否相等？机器数各是什么？**（用十六进制表示）  
【解析】返回值相同。因为f(23)=2^（23+1） -1=2^24 -1，其二进制形式为24个1，即机器数为00FF FFFFH，int占32位所以没有溢出。float有1个符号位，8个指数位，23个底数位，并且隐含一位，所以23个底数位可以表示24位的底数。  
求f2(23)机器数：因为符号位为0，指数位为23+127=150的二进制为1001 0110，底数位为23个1即111 1111 1111 1111 1111 1111，所以f2(23)的机器数为0100 1011 0111 ...(20个1)，十六进制表示为4B7F FFFFH。

## 64.是否在同个块

像14年和19年真题给出一段C语言程序及其（行号、虚拟地址、机器指令、汇编指令）这类题很常见。  
特别注意：14年说的地址是“程序段的地址”，其实是《虚拟地址》，但后面问了所在地址0804 8100H-0804 8114H这段程序指令是否在同一个主存块内——物理角度。  
**【14年】M 的指令 Cache 和数据 Cache 分离。若指令 Cache 共有 16 行，Cache 和主存交换的块大小为 32 字节，则其数据区的容量是多少？若仅考虑程序段 P 的执行，则指令 Cache 的命中率为多少？**  
【解析】P 共有 6 条指令，占 24 字节，小于主存块大小(32B)，其起始地址为 0804 8100H，对应一块的开始位置，由此可知所有指令都在一个主存块内（注：从每块大小为32B知块内地址为最后的5位二进制位即0 0000B，而此处注意起始地址0804 8100H这个地址是十六进制，不要误以为是最后的5位十六进制位了）。

## 65.